{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"graphreadability","text":"<p>Python module for applying readability metrics to network and graph visualizations.</p>"},{"location":"#credits","title":"Credits","text":"<p>Created by Philip Englund Mathieu, MS DS '24, as part of Northeastern University's Khoury College of Computer Sciences Research Apprenticeship program. Advised by Prof. Cody Dunne. For additional attributions, see the dedicated references page.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install graphreadability\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code># Suggested import syntax\nimport networkx as nx\nimport graphreadability as gr\n\n# Create a basic graph using NetworkX\nG = nx.Graph()\nG.add_nodes_from(\n    [\n        (1, {\"x\": 1, \"y\": 1}),\n        (2, {\"x\": -1, \"y\": 1}),\n        (3, {\"x\": -1, \"y\": -1}),\n        (4, {\"x\": 1, \"y\": -1}),\n        (5, {\"x\": 2, \"y\": 1}),\n    ]\n)\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 2), (1, 3)])\n\n# Create a MetricsSuite to calculate readability metrics\nM = gr.MetricsSuite(G)\n\n# Calculate readability metrics\nM.calculate_metrics()\n\n# Print results\nM.pretty_print_metrics()\n</code></pre> <p>Expected Output:</p> <pre><code>--------------------------------------------------\nMetric                        Value     Weight\n--------------------------------------------------\nangular_resolution            0.312     1\naspect_ratio                  0.667     1\ncrossing_angle                1.000     1\nedge_crossing                 1.000     1\nedge_length                   0.829     1\nedge_orthogonality            0.600     1\ngabriel_ratio                 0.556     1\nneighbourhood_preservation    0.333     1\nnode_orthogonality            0.417     1\nnode_resolution               0.277     1\nnode_uniformity               0.812     1\n--------------------------------------------------\nEvaluation using weighted_sum: 0.61855\n--------------------------------------------------\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is built with MkDocs - for full documentation visit mkdocs.org. To install the packages needed for local development, run: <pre><code>pip install graphreadability[docs]\n</code></pre></p> <p>This will install <code>mkdocs</code> (documentation generator), <code>mkdocs-material</code> (theme), <code>mkdocstrings</code> (plugin adding lots of cross-referencing abilities), and <code>mkdocstrings-python</code> (the additional handler needed for Python).</p>"},{"location":"contributing/#mkdocs-commands","title":"MkDocs Commands","text":"<ul> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"contributing/#mkdocs-project-layout","title":"MkDocs Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"metrics/","title":"Supported Metrics","text":"<p>This page documents the metrics included with the current version. The contents are generated directly from the <code>graphreadability.metrics.metrics.py</code>.</p> <p>This module contains all metric functions. A metric should be a function that takes a NetworkX graph as the first argument and returns a float. It may also take additional arguments, which should be specified in the docstring.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.__count_crossings","title":"<code>__count_crossings(G, crosses_limit=1000000.0)</code>","text":"<p>Count the number of edge crossings in a graph.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.__count_crossings--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.__count_crossings--returns","title":"Returns","text":"<p>int     The number of edge crossings in the graph.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def __count_crossings(G, crosses_limit=1e6):\n    \"\"\"\n    Count the number of edge crossings in a graph.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n\n    Returns\n    -------\n    int\n        The number of edge crossings in the graph.\n    \"\"\"\n\n    covered = []  # List to keep track of covered edges\n    c = 0  # Counter for edge crossings\n\n    for e in G.edges:\n        a_p1 = (G.nodes[e[0]][\"x\"], G.nodes[e[0]][\"y\"])  # Position of source node of e\n        a_p2 = (G.nodes[e[1]][\"x\"], G.nodes[e[1]][\"y\"])  # Position of target node of e\n        line_a = (a_p1, a_p2)  # Line segment of edge e\n\n        for e2 in G.edges:\n            if c &gt; crosses_limit:\n                raise ValueError(\n                    f\"Number of edge crossings exceeds the limit of {crosses_limit}\"\n                )\n\n            if e == e2:\n                continue  # Skip if the edges are the same\n\n            b_p1 = (\n                G.nodes[e2[0]][\"x\"],\n                G.nodes[e2[0]][\"y\"],\n            )  # Position of source node of e2\n            b_p2 = (\n                G.nodes[e2[1]][\"x\"],\n                G.nodes[e2[1]][\"y\"],\n            )  # Position of target node of e2\n            line_b = (b_p1, b_p2)  # Line segment of edge e2\n\n            if helpers._intersect(line_a, line_b) and (line_a, line_b) not in covered:\n                covered.append((line_b, line_a))  # Mark the edges as covered\n                c += 1  # Increment the counter for edge crossings\n\n    return c\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.__crossing_angle_old","title":"<code>__crossing_angle_old(G, crossing_limit=1000000.0)</code>","text":"<p>Calculate the metric for the edge crossings angle. crossing_limit specifies the maximum number of crossings allowed, which is limited due to long execution times.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def __crossing_angle_old(G, crossing_limit=1e6):\n    \"\"\"Calculate the metric for the edge crossings angle. crossing_limit specifies the maximum number of crossings allowed,\n    which is limited due to long execution times.\"\"\"\n\n    angles_sum = 0\n    num_minor_nodes = 0\n    for node in G.nodes:\n        # Only crosses promoted nodes should be counted\n        if not crosses_promotion._is_minor(node, G):\n            continue\n\n        num_minor_nodes += 1\n        ideal = (\n            360 / G.degree[node]\n        )  # This should always be 90 degrees, except in rare cases where multiple edges intersect at the exact same point\n\n        x1, y1 = G.nodes[node][\"x\"], G.nodes[node][\"y\"]\n        actual_min = 360\n\n        # Iterate over adjacent edges and calculate the difference of the minimum angle from the ideal angle\n        for adj in G.neighbors(node):\n            x2, y2 = G.nodes[adj][\"x\"], G.nodes[adj][\"y\"]\n            angle1 = np.degrees(np.arctan2((y2 - y1), (x2 - x1)))\n\n            for adj2 in G.neighbors(node):\n                if adj == adj2:\n                    continue\n\n                x3, y3 = G.nodes[adj2][\"x\"], G.nodes[adj2][\"y\"]\n                angle2 = np.degrees(np.arctan2((y3 - y1), (x3 - x1)))\n\n                diff = abs(angle1 - angle2)\n\n                if diff &lt; actual_min:\n                    actual_min = diff\n\n        angles_sum += abs((ideal - actual_min) / ideal)\n\n    if num_minor_nodes == 0:\n        print(\"Warning: No minor nodes found. Did you run crosses promotion?\")\n        return 1\n\n    # Return 1 minus the average of minimum angles\n    return 1 - (angles_sum / num_minor_nodes) if num_minor_nodes &gt; 0 else 1\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.__stress","title":"<code>__stress(G)</code>","text":"<p>Calculate the metric for stress.</p> <p>Stress is a measure of how well the graph preserves the pairwise distances between nodes.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.__stress--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.__stress--returns","title":"Returns","text":"<p>float     The stress metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def __stress(G):\n    \"\"\"Calculate the metric for stress.\n\n    Stress is a measure of how well the graph preserves the pairwise distances between nodes.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n\n    Returns\n    -------\n    float\n        The stress metric.\n    \"\"\"\n    # Create a single matrix of all node locations\n    X = np.array([[float(G.nodes[n][\"x\"]), float(G.nodes[n][\"y\"])] for n in G.nodes()])\n    N = len(X)\n\n    # Create a sorted dictionary of the shortest path lengths between all pairs of nodes\n    all_pairs_shortest = dict(nx.all_pairs_shortest_path_length(G))\n    all_pairs_shortest = dict(sorted(all_pairs_shortest.items()))\n\n    # Create a matrix of the shortest path lengths between all pairs of nodes\n    d = np.zeros((N, N))\n    for i, k in enumerate(all_pairs_shortest):\n        all_pairs_shortest[k] = dict(sorted(all_pairs_shortest[k].items()))\n        d[i] = [float(v) for v in all_pairs_shortest[k].values()]\n\n    from math import comb\n\n    ss = (X * X).sum(axis=1)\n\n    diff = np.sqrt(abs(ss.reshape((N, 1)) + ss.reshape((1, N)) - 2 * np.dot(X, X.T)))\n\n    np.fill_diagonal(diff, 0)\n\n    def stress_func(a):\n        return np.sum(\n            np.square(np.divide((a * diff - d), d, out=np.zeros_like(d), where=d != 0))\n        ) / comb(N, 2)\n\n    from scipy.optimize import minimize_scalar\n\n    min_a = minimize_scalar(stress_func)\n\n    if not min_a.success:\n        raise ValueError(f\"Failed to minimize stress function: {min_a.message}\")\n\n    return stress_func(a=min_a.x)\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.angular_resolution","title":"<code>angular_resolution(G, all_nodes=False)</code>","text":"<p>Calculate the metric for angular resolution.</p> <p>This metric captures how evenly the edges leaving a node are distributed. If all_nodes is True, include nodes with degree 1, for which the angle will always be perfect.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.angular_resolution--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for. all_nodes : bool     Whether to include all nodes in the calculation.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.angular_resolution--returns","title":"Returns","text":"<p>float     The angular resolution metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def angular_resolution(G, all_nodes=False):\n    \"\"\"Calculate the metric for angular resolution.\n\n    This metric captures how evenly the edges leaving a node are distributed. If all_nodes is True, include\n    nodes with degree 1, for which the angle will always be perfect.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n    all_nodes : bool\n        Whether to include all nodes in the calculation.\n\n    Returns\n    -------\n    float\n        The angular resolution metric.\n    \"\"\"\n    angles_sum = 0\n    nodes_count = 0\n    for node in G.nodes:\n        if G.degree[node] &lt;= 1:\n            continue\n\n        nodes_count += 1\n        ideal = (\n            360 / G.degree[node]\n        )  # Each node has an ideal angle for adjacent edges, based on the number of adjacent edges\n\n        x1, y1 = G.nodes[node][\"x\"], G.nodes[node][\"y\"]\n        actual_min = 360\n\n        # Iterate over adjacent edges and calculate the difference of the minimum angle from the ideal angle\n        for adj in G.neighbors(node):\n            x2, y2 = G.nodes[adj][\"x\"], G.nodes[adj][\"y\"]\n            angle1 = np.degrees(np.arctan2((y2 - y1), (x2 - x1)))\n\n            for adj2 in G.neighbors(node):\n                if adj == adj2:\n                    continue\n\n                x3, y3 = G.nodes[adj2][\"x\"], G.nodes[adj2][\"y\"]\n                angle2 = np.degrees(np.arctan2((y3 - y1), (x3 - x1)))\n\n                diff = abs(angle2 - angle1)\n\n                if diff &lt; actual_min:\n                    actual_min = diff\n\n        angles_sum += abs((ideal - actual_min) / ideal)\n\n    # Return 1 minus the average of minimum angles\n    return (\n        1 - (angles_sum / G.number_of_nodes())\n        if all_nodes\n        else 1 - (angles_sum / nodes_count)\n    )\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.aspect_ratio","title":"<code>aspect_ratio(G)</code>","text":"<p>Calculate the metric for aspect ratio.</p> <p>Aspect ratio is the ratio of the width to the height of the smallest bounding box that contains all nodes.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.aspect_ratio--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.aspect_ratio--returns","title":"Returns","text":"<p>float     The aspect ratio metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def aspect_ratio(G):\n    \"\"\"Calculate the metric for aspect ratio.\n\n    Aspect ratio is the ratio of the width to the height of the smallest bounding box that contains all nodes.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n\n    Returns\n    -------\n    float\n        The aspect ratio metric.\n    \"\"\"\n    bbox = helpers._get_bounding_box(G)\n\n    width = bbox[1, 0] - bbox[0, 0]\n    height = bbox[1, 1] - bbox[0, 1]\n\n    if width &gt; height:\n        return height / width\n    else:\n        return width / height\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.crossing_angle","title":"<code>crossing_angle(G, crossing_limit=1000000.0)</code>","text":"<p>Calculate the metric for the edge crossings angle.</p> <p>The edge crossings angle metric compares the angle of a crossing to an ideal angle. crossing_limit specifies the maximum number of crossings allowed, which is limited due to long execution times.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.crossing_angle--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for. crossing_limit : int     The maximum number of crossings allowed.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.crossing_angle--returns","title":"Returns","text":"<p>float     The edge crossings angle metric.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.crossing_angle--raises","title":"Raises","text":"<p>ValueError     If the number of edges exceeds the crossing limit.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def crossing_angle(G, crossing_limit=1e6):\n    \"\"\"Calculate the metric for the edge crossings angle.\n\n    The edge crossings angle metric compares the angle of a crossing to an ideal angle. crossing_limit specifies\n    the maximum number of crossings allowed, which is limited due to long execution times.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n    crossing_limit : int\n        The maximum number of crossings allowed.\n\n    Returns\n    -------\n    float\n        The edge crossings angle metric.\n\n    Raises\n    ------\n    ValueError\n        If the number of edges exceeds the crossing limit.\n    \"\"\"\n    if G.number_of_edges() &gt; crossing_limit:\n        raise ValueError(\n            f\"Number of edges exceeds the crossing limit of {crossing_limit}\"\n        )\n\n    # Check if graph edges have edge_crossings attribute\n    if not nx.get_edge_attributes(G, \"edge_crossings\"):\n        _calculate_edge_crossings(G)\n\n    edge_crossings = nx.get_edge_attributes(G, \"edge_crossings\")\n\n    angles_sum = 0\n    for crossing in edge_crossings.values():\n        ideal = 180 / (\n            crossing[\"count\"] + 1\n        )  # Each crossing adds an additional edge, so the ideal angle is 180 / (count + 1)\n        angles_sum += sum(\n            [abs((ideal - angle) % ideal) / ideal for angle in crossing[\"angles\"]]\n        )\n    return 1 - helpers.divide_or_zero(angles_sum, len(edge_crossings))\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_crossing","title":"<code>edge_crossing(G, subtract_tri=True, subtract_4=True)</code>","text":"<p>Calculate the metric for the number of edge_crossing, scaled against the total number of possible crossings.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_crossing--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for. verbose : bool     Whether to print additional information about the metric.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_crossing--returns","title":"Returns","text":"<p>float     The edge crossing metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def edge_crossing(G, subtract_tri=True, subtract_4=True):\n    \"\"\"Calculate the metric for the number of edge_crossing, scaled against the total\n    number of possible crossings.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n    verbose : bool\n        Whether to print additional information about the metric.\n\n    Returns\n    -------\n    float\n        The edge crossing metric.\n    \"\"\"\n    # Estimate for the upper bound for the number of edge crossings\n    m = G.number_of_edges()\n    c_all = (m * (m - 1)) / 2\n\n    # Calculate the number of impossible crossings based on the node degrees\n    degree = np.array([degree[1] for degree in G.degree()])\n    c_deg = np.dot(degree, degree - 1) / 2\n\n    # Calculate the maximum number of possible crossings\n    c_mx = c_all - c_deg\n\n    if subtract_tri:\n        c_mx -= _count_impossible_triangle_crossings(G)\n\n    if subtract_4:\n        c_mx -= _count_4_cycles(G)\n\n    # Retrieve the edge crossings from the graph if they have been calculated, otherwise calculate\n    if not nx.get_edge_attributes(G, \"edge_crossings\"):\n        crossings, angles = _calculate_edge_crossings(G)\n    else:\n        edge_crossings = nx.get_edge_attributes(G, \"edge_crossings\")\n        crossings = set()\n        for edge, crossing in edge_crossings.items():\n            if crossing[\"count\"] &gt; 0:\n                crossings.add(edge)\n\n    # Calculate the number of edge crossings\n    c = len(crossings)\n\n    return 1 - helpers.divide_or_zero(c, c_mx)\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_length","title":"<code>edge_length(G, ideal_edge_length=None)</code>","text":"<p>Calculate the edge length metric.</p> <p>The edge length metric compares the edge lengths to an ideal length. Default ideal is average of all edge lengths.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_length--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for. ideal : float     The ideal edge length.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_length--returns","title":"Returns","text":"<p>float     The edge length metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def edge_length(G, ideal_edge_length=None):\n    \"\"\"Calculate the edge length metric.\n\n    The edge length metric compares the edge lengths to an ideal length. Default ideal is average of all edge lengths.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n    ideal : float\n        The ideal edge length.\n\n    Returns\n    -------\n    float\n        The edge length metric.\n    \"\"\"\n    if not ideal_edge_length:\n        # For unweighted graphs, set the ideal edge length to the average edge length\n        ideal_edge_length = 0\n        for edge in G.edges:\n            a = G.nodes[edge[0]][\"x\"], G.nodes[edge[0]][\"y\"]\n            b = G.nodes[edge[1]][\"x\"], G.nodes[edge[1]][\"y\"]\n\n            ideal_edge_length += helpers._euclidean_distance(a, b)\n        ideal_edge_length = ideal_edge_length / G.number_of_edges()\n\n    edge_length_sum = 0\n    for edge in G.edges:\n        a = G.nodes[edge[0]][\"x\"], G.nodes[edge[0]][\"y\"]\n        b = G.nodes[edge[1]][\"x\"], G.nodes[edge[1]][\"y\"]\n        edge_length_sum += (\n            abs(ideal_edge_length - helpers._euclidean_distance(a, b))\n            / ideal_edge_length\n        )\n\n    # Remove negatives\n    if edge_length_sum &gt; G.number_of_edges():\n        return 1 - abs(1 - (edge_length_sum / G.number_of_edges()))\n\n    return 1 - (edge_length_sum / G.number_of_edges())\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_orthogonality","title":"<code>edge_orthogonality(G)</code>","text":"<p>Calculate the metric for edge orthogonality.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_orthogonality--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for. optimal_angle : float     The optimal angle for edge orthogonality.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.edge_orthogonality--returns","title":"Returns","text":"<p>float     The edge orthogonality metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def edge_orthogonality(G):\n    \"\"\"Calculate the metric for edge orthogonality.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n    optimal_angle : float\n        The optimal angle for edge orthogonality.\n\n    Returns\n    -------\n    float\n        The edge orthogonality metric.\n    \"\"\"\n    ortho_list = []\n\n    # Iterate over each edge and get it's minimum angle relative to the orthogonal grid\n    for e in G.edges:\n        source = e[0]\n        target = e[1]\n\n        x1, y1 = G.nodes[source][\"x\"], G.nodes[source][\"y\"]\n        x2, y2 = G.nodes[target][\"x\"], G.nodes[target][\"y\"]\n\n        try:\n            gradient = (y2 - y1) / (x2 - x1)\n        except ZeroDivisionError:\n            gradient = 0\n\n        angle = np.degrees(np.arctan(abs(gradient)))\n\n        edge_ortho = min(angle, abs(90 - angle), 180 - angle) / 45\n        ortho_list.append(edge_ortho)\n\n    # Return 1 minus the average of minimum angles\n    return 1 - (sum(ortho_list) / G.number_of_edges())\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.gabriel_ratio","title":"<code>gabriel_ratio(G)</code>","text":"<p>Calculate the metric for the gabriel ratio.</p> <p>A graph is a Gabriel graph if no node falls within the area of any circles constructed using each edge as its diameter.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.gabriel_ratio--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.gabriel_ratio--returns","title":"Returns","text":"<p>float     The gabriel ratio metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def gabriel_ratio(G):\n    \"\"\"Calculate the metric for the gabriel ratio.\n\n    A graph is a Gabriel graph if no node falls within the area of any circles constructed using each edge as its diameter.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n\n    Returns\n    -------\n    float\n        The gabriel ratio metric.\n    \"\"\"\n\n    # Initial upper bound on number of nodes which could potentially be violating nodes\n    possible_non_conforming = (G.number_of_edges() * G.number_of_nodes()) - (\n        G.number_of_edges() * 2\n    )\n\n    num_non_conforming = 0\n\n    # Iterate over each edge\n    for edge in G.edges:\n\n        # Get the equation of the circle with the edge as its diameter\n        a = G.nodes[edge[0]][\"x\"], G.nodes[edge[0]][\"y\"]\n        b = G.nodes[edge[1]][\"x\"], G.nodes[edge[1]][\"y\"]\n\n        r = helpers._euclidean_distance(a, b) / 2\n        center_x, center_y = helpers._midpoint(edge[0], edge[1], G)\n\n        # Check if any nodes fall with within the circle and increment the counter if they do\n        for node in G.nodes:\n            if edge[0] == node or edge[1] == node:\n                continue\n\n            x, y = G.nodes[node][\"x\"], G.nodes[node][\"y\"]\n\n            if helpers._in_circle(x, y, center_x, center_y, r):\n                num_non_conforming += 1\n                # If the node is adjacent to either node in the current edge reduce total by 1,\n                # since the nodes cannot both simultaneously be in each others circle\n                if node in G.neighbors(edge[0]):\n                    possible_non_conforming -= 1\n                if node in G.neighbors(edge[1]):\n                    possible_non_conforming -= 1\n\n    # Return 1 minus the ratio of non conforming nodes to the upper bound on possible non conforming nodes.\n    return (\n        1 - (num_non_conforming / possible_non_conforming)\n        if possible_non_conforming &gt; 0\n        else 1\n    )\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.neighbourhood_preservation","title":"<code>neighbourhood_preservation(G, k=None)</code>","text":"<p>Calculate the metric for neighbourhood preservation.</p> <p>Neighbourhood preservation is the average of the ratio of the number of neighbors by edges to the number of neighbors by k-nearest neighbors. This metric attempts to capture how well the geometry of the graph preserves the topology of the graph.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.neighbourhood_preservation--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for. k : int     The number of nearest neighbours to consider.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.neighbourhood_preservation--returns","title":"Returns","text":"<p>float     The neighbourhood preservation metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def neighbourhood_preservation(G, k=None):\n    \"\"\"Calculate the metric for neighbourhood preservation.\n\n    Neighbourhood preservation is the average of the ratio of the number of neighbors by edges to the number\n    of neighbors by k-nearest neighbors. This metric attempts to capture how well the geometry of the graph\n    preserves the topology of the graph.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n    k : int\n        The number of nearest neighbours to consider.\n\n    Returns\n    -------\n    float\n        The neighbourhood preservation metric.\n    \"\"\"\n    N = G.number_of_nodes()\n\n    # Default to average degree\n    if k is None:\n        k = np.floor(helpers.avg_degree(G)).astype(int)\n\n    adj = nx.to_numpy_array(G)\n    K = np.zeros_like(adj)\n\n    # Get node positions\n    points = helpers._graph_to_points(G)\n\n    # Build KD tree\n    tree = helpers._build_kd_tree(points)\n\n    # Find k nearest neighbours for each node\n    for i, u in enumerate(G.nodes()):\n        nearest = helpers._find_k_nearest_points(points[i], k + 1, tree=tree)\n        for j in nearest[1:]:\n            K[i][j] = 1\n\n    # Remove diagonal\n    np.fill_diagonal(K, 0)\n\n    # Calculate the ratio of neighbours to k-nearest neighbours\n    intersection = np.logical_and(adj, K)\n    union = np.logical_or(adj, K)\n    return intersection.sum() / union.sum()\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.node_orthogonality","title":"<code>node_orthogonality(G)</code>","text":"<p>Calculate the metric for node orthogonality.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def node_orthogonality(G):\n    \"\"\"Calculate the metric for node orthogonality.\"\"\"\n    coord_set = []\n\n    # Start with random node\n    first_node = rand.sample(list(G.nodes), 1)[0]\n    min_x, min_y = (\n        G.nodes[first_node][\"x\"],\n        G.nodes[first_node][\"y\"],\n    )\n\n    # Find minimum x and y positions\n    for node in G.nodes:\n        x = G.nodes[node][\"x\"]\n        y = G.nodes[node][\"y\"]\n\n        if x &lt; min_x:\n            min_x = x\n        elif y &lt; min_y:\n            min_y = y\n\n    x_distance = abs(0 - float(min_x))\n    y_distance = abs(0 - float(min_y))\n\n    # Adjust graph so node with minimum coordinates is at 0,0\n    for node in G.nodes:\n        G.nodes[node][\"x\"] = float(G.nodes[node][\"x\"]) - x_distance\n        G.nodes[node][\"y\"] = float(G.nodes[node][\"y\"]) - y_distance\n\n    # Start with random node\n    first_node = rand.sample(list(G.nodes), 1)[0]\n\n    min_x, min_y = (\n        G.nodes[first_node][\"x\"],\n        G.nodes[first_node][\"y\"],\n    )\n    max_x, max_y = (\n        G.nodes[first_node][\"x\"],\n        G.nodes[first_node][\"y\"],\n    )\n\n    for node in G.nodes:\n        x, y = G.nodes[node][\"x\"], G.nodes[node][\"y\"]\n\n        coord_set.append(x)\n        coord_set.append(y)\n\n        # Get GCD of node positions\n        gcd = int(float(coord_set[0]))\n        for coord in coord_set[1:]:\n            gcd = np.gcd(int(float(gcd)), int(float(coord)))\n\n        # Get maximum and minimum coordinates\n        if x &gt; max_x:\n            max_x = x\n        elif x &lt; min_x:\n            min_x = x\n\n        if y &gt; max_y:\n            max_y = y\n        elif y &lt; min_y:\n            min_y = y\n\n    # Get size of unit grid\n    h = abs(max_y - min_y)\n    w = abs(max_x - min_x)\n\n    reduced_h = h / gcd\n    reduced_w = w / gcd\n\n    A = (reduced_w + 1) * (reduced_h + 1)\n\n    # Return number of nodes on the unit grid weighted against the number of positions on the unit grid\n    return len(G.nodes) / A\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.node_resolution","title":"<code>node_resolution(G)</code>","text":"<p>Calculate the metric for node resolution.</p> <p>Node resolution is the ratio of the smallest and largest distance between any pair of nodes.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.node_resolution--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.node_resolution--returns","title":"Returns","text":"<p>float     The node resolution metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def node_resolution(G):\n    \"\"\"Calculate the metric for node resolution.\n\n    Node resolution is the ratio of the smallest and largest distance between any pair of nodes.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n\n    Returns\n    -------\n    float\n        The node resolution metric.\n    \"\"\"\n    # Start with two random nodes\n    first_node, second_node = rand.sample(list(G.nodes), 2)\n    a = G.nodes[first_node][\"x\"], G.nodes[first_node][\"y\"]\n    b = G.nodes[second_node][\"x\"], G.nodes[second_node][\"y\"]\n\n    min_dist = helpers._euclidean_distance(a, b)\n    max_dist = min_dist\n\n    # Iterate over every pair of nodes, keeping track of the maximum and minimum distances between them\n    nodes = list(G.nodes)\n    for idx, i in enumerate(nodes):\n        for j in nodes[idx + 1 :]:\n\n            a = G.nodes[i][\"x\"], G.nodes[i][\"y\"]\n            b = G.nodes[j][\"x\"], G.nodes[j][\"y\"]\n\n            d = helpers._euclidean_distance(a, b)\n\n            if d &lt; min_dist:\n                min_dist = d\n\n            if d &gt; max_dist:\n                max_dist = d\n\n    return min_dist / max_dist\n</code></pre>"},{"location":"metrics/#graphreadability.metrics.metrics.node_uniformity","title":"<code>node_uniformity(G)</code>","text":"<p>Calculate the metric for node uniformity.</p> <p>Node uniformity is the ratio of the number of nodes to the number of cells in a grid that contains all nodes.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.node_uniformity--parameters","title":"Parameters","text":"<p>G : nx.Graph     The graph to calculate the metric for.</p>"},{"location":"metrics/#graphreadability.metrics.metrics.node_uniformity--returns","title":"Returns","text":"<p>float     The node uniformity metric.</p> Source code in <code>graphreadability/metrics/metrics.py</code> <pre><code>def node_uniformity(G):\n    \"\"\"Calculate the metric for node uniformity.\n\n    Node uniformity is the ratio of the number of nodes to the number of cells in a grid that contains all nodes.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        The graph to calculate the metric for.\n\n    Returns\n    -------\n    float\n        The node uniformity metric.\n    \"\"\"\n\n    points = helpers._graph_to_points(G)\n    bbox = helpers._bounding_box(points)\n    x_min, y_min, x_max, y_max = bbox.flatten().tolist()\n\n    num_points = len(points)\n    num_cells = int(np.sqrt(num_points))\n\n    cell_width = (x_max - x_min) / num_cells\n    cell_height = (y_max - y_min) / num_cells\n\n    grid = [[0 for _ in range(num_cells)] for _ in range(num_cells)]\n\n    for i in range(num_cells):\n        for j in range(num_cells):\n            for point in points:\n                square = (\n                    (x_min + (i * cell_width)),\n                    (y_min + (j * cell_height)),\n                ), (\n                    (x_min + ((i + 1) * cell_width)),\n                    (y_min + ((j + 1) * cell_height)),\n                )\n                # print(square)\n                if helpers._is_point_inside_square(\n                    *point,\n                    square[0][0],\n                    square[0][1],\n                    square[1][0],\n                    square[1][1],\n                ):\n                    grid[i][j] += 1\n\n    total_cells = num_cells * num_cells\n    average_points_per_cell = num_points / total_cells\n    evenness = sum(\n        abs(cell - average_points_per_cell) for row in grid for cell in row\n    ) / (2 * total_cells)\n    return 1 - evenness if evenness &lt; 1 else 0\n</code></pre>"},{"location":"metricssuite/","title":"MetricsSuite","text":"<p>A suite for calculating several metrics for graph drawing aesthetics, as well as methods for combining these into a single cost function.</p>"},{"location":"metricssuite/#graphreadability.MetricsSuite--parameters","title":"Parameters","text":"<p>graph : Union[nx.Graph, str], optional     The graph to be analyzed. Can be a NetworkX Graph object or a path to a GML or GraphML file. metric_weights : Optional[dict], optional     Dictionary of metric:weight key/values. Default is DEFAULT_WEIGHTS. metric_combination_strategy : str, optional     The multiple criteria decision analysis technique to use for combining metrics. Default is \"weighted_sum\". sym_threshold : Union[int, float], optional     The threshold for symmetry detection. Default is 2. sym_tolerance : Union[int, float], optional     The tolerance for symmetry detection. Default is 3. file_type : str, optional     The file type of the graph file. Default is \"GraphML\".</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>class MetricsSuite:\n    \"\"\"\n    A suite for calculating several metrics for graph drawing aesthetics, as well as methods for\n    combining these into a single cost function.\n\n    Parameters\n    ----------\n    graph : Union[nx.Graph, str], optional\n        The graph to be analyzed. Can be a NetworkX Graph object or a path to a GML or GraphML file.\n    metric_weights : Optional[dict], optional\n        Dictionary of metric:weight key/values. Default is DEFAULT_WEIGHTS.\n    metric_combination_strategy : str, optional\n        The multiple criteria decision analysis technique to use for combining metrics. Default is \"weighted_sum\".\n    sym_threshold : Union[int, float], optional\n        The threshold for symmetry detection. Default is 2.\n    sym_tolerance : Union[int, float], optional\n        The tolerance for symmetry detection. Default is 3.\n    file_type : str, optional\n        The file type of the graph file. Default is \"GraphML\".\n    \"\"\"\n\n    def __init__(\n        self,\n        G: Union[nx.Graph, str] = None,\n        metric_weights: Optional[dict] = DEFAULT_WEIGHTS,\n        metric_combination_strategy: str = \"weighted_sum\",\n        sym_threshold: Union[int, float] = 2,\n        sym_tolerance: Union[int, float] = 3,\n        file_type: str = \"GraphML\",\n        copy=False,\n    ):\n        # Dictionary mapping metric combination strategies to their functions\n        self.metric_combination_strategies = {\n            \"weighted_sum\": self.weighted_sum,\n            \"weighted_prod\": self.weighted_prod,\n        }\n        # Placeholder for version of graph with crosses promoted to nodes\n        self.graph_cross_promoted = None\n        # Dictionary mapping metric names to their functions, values, and weights\n        self.metrics = METRICS.copy()\n        for k in self.metrics.keys():\n            self.metrics[k].update({\"weight\": None, \"value\": None})\n\n        # Check all metrics given are valid and assign weights\n        self.initial_weights = self.set_weights(metric_weights)\n\n        # Check metric combination strategy is valid\n        assert (\n            metric_combination_strategy in self.metric_combination_strategies\n        ), f\"Unknown metric combination strategy: {metric_combination_strategy}. Available strategies: {list(self.metric_combination_strategies.keys())}\"\n        self.metric_combination_strategy = metric_combination_strategy\n\n        if G is None:\n            self._filename = \"\"\n            self.G = self.load_graph_test()\n        elif isinstance(G, str):\n            self._filename = G\n            self.G = self.load_graph(G, file_type=file_type)\n        elif isinstance(G, nx.Graph):\n            self._filename = \"\"\n            if copy:\n                self.G = G.copy()\n            else:\n                self.G = G\n        else:\n            raise TypeError(\n                f\"'graph' must be a string representing a path to a GML or GraphML file, or a NetworkX Graph object, not {type(G)}\"\n            )\n\n        if sym_tolerance &lt; 0:\n            raise ValueError(\"sym_tolerance must be positive.\")\n\n        self.sym_tolerance = sym_tolerance\n\n        if sym_threshold &lt; 0:\n            raise ValueError(\"sym_threshold must be positive.\")\n\n        self.sym_threshold = sym_threshold\n\n    def __repr__(self):\n        \"\"\"Return a detailed string representation of the MetricsSuite object.\"\"\"\n        return (\n            f\"MetricsSuite(graph={self._filename}, metric_weights={self.initial_weights}, \"\n            f\"metric_combination_strategy={self.metric_combination_strategy}, sym_threshold={self.sym_threshold}, \"\n            \"sym_tolerance={self.sym_tolerance})\"\n        )\n\n    def __str__(self):\n        \"\"\"Return a concise string representation of the MetricsSuite object.\"\"\"\n        return (\n            f\"MetricsSuite({self._filename}) object with {len(self.metrics)} metrics.\"\n        )\n\n    def __copy__(self):\n        \"\"\"Return a shallow copy of the MetricsSuite object.\"\"\"\n        return MetricsSuite(\n            G=self.G,\n            metric_weights=self.initial_weights,\n            metric_combination_strategy=self.metric_combination_strategy,\n            sym_threshold=self.sym_threshold,\n            sym_tolerance=self.sym_tolerance,\n        )\n\n    def __deepcopy__(self, memo):\n        \"\"\"Return a deep copy of the MetricsSuite object.\"\"\"\n        return MetricsSuite(\n            G=self.G.copy(),\n            metric_weights=self.initial_weights,\n            metric_combination_strategy=self.metric_combination_strategy,\n            sym_threshold=self.sym_threshold,\n            sym_tolerance=self.sym_tolerance,\n        )\n\n    def load_graph_test(self, nxg=nx.sedgewick_maze_graph):\n        \"\"\"Loads a test graph with a random layout.\"\"\"\n        G = nxg()\n        pos = nx.random_layout(G)\n        for k, v in pos.items():\n            pos[k] = {\"x\": v[0], \"y\": v[1]}\n\n        nx.set_node_attributes(G, pos)\n        return G\n\n    def copy(self, deep=True, memo=None):\n        \"\"\"Return a copy of the MetricsSuite object, defaulting to a deep copy.\"\"\"\n        if deep is True or memo is not None:\n            return self.__deepcopy__(memo)\n        else:\n            return self.__copy__()\n\n    def set_weights(self, metric_weights: Sequence[float]):\n        \"\"\"Set the weights of the metrics in the MetricsSuite object.\n\n        Parameters\n        ----------\n        metric_weights : dict\n            Dictionary of metric:weight key/values.\n\n        Returns\n        -------\n        dict\n            Dictionary of metric:weight key/values for metrics with non-zero weights.\n        \"\"\"\n        metric_weights = {\n            metric: weight for metric, weight in metric_weights.items() if weight &gt; 0\n        }\n\n        if any(metric_weights[metric] &lt; 0 for metric in metric_weights):\n            raise ValueError(\"Metric weights must be positive.\")\n\n        for metric in self.metrics:\n            self.metrics[metric][\"weight\"] = (\n                metric_weights[metric] if metric in metric_weights else None\n            )\n\n        return {\n            metric: weight for metric, weight in metric_weights.items() if weight &gt; 0\n        }\n\n    def apply_layout(self, pos):\n        \"\"\"Applies the given layout to the graph.\n\n        Parameters\n        ----------\n        pos : dict(node_id, tuple(float, float))\n            Dictionary of node positions.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # Convert to x and y attributes\n        xy = {k: {\"x\": v[0], \"y\": v[1]} for k, v in pos.items()}\n        nx.set_node_attributes(self.G, xy)\n\n    def calculate_metric(self, metric: str = None):\n        \"\"\"Calculate the value of the given metric by calling the associated function.\"\"\"\n        if metric is None:\n            raise ValueError(\n                \"No metric provided. Did you mean to call calculate_metrics()?\"\n            )\n\n        try:\n            self.metrics[metric][\"value\"] = self.metrics[metric][\"func\"](self.G)\n        except Exception as e:\n            print(f\"Error calculating metric {metric}: {e}\")\n            self.metrics[metric][\"value\"] = None\n\n    def calculate_metrics(self, calculate_all=False):\n        \"\"\"Calculates the values of all metrics with non-zero weights.\"\"\"\n        n_metrics = 0\n        for metric in self.metrics:\n            if self.metrics[metric][\"weight\"] is not None or calculate_all:\n                self.calculate_metric(metric)\n                n_metrics += 1\n\n    def reset_metrics(self):\n        \"\"\"Resets all metric values and is_calculated flags to None and False, respectively.\"\"\"\n        for metric in self.metrics:\n            self.metrics[metric][\"value\"] = None\n            self.metrics[metric][\"is_calculated\"] = False\n\n    def weighted_prod(self):\n        \"\"\"Returns the weighted product of all metrics. Should NOT be used as a cost function - may be useful for comparing graphs.\"\"\"\n        used_metrics = [\n            metric\n            for metric in self.metrics.keys()\n            if self.metrics[metric][\"weight\"] is not None\n        ]\n        for metric in used_metrics:\n            if self.metrics[metric][\"value\"] is None:\n                self.calculate_metric(metric)\n        return math.prod(\n            self.metrics[metric][\"value\"] * self.metrics[metric][\"weight\"]\n            for metric in used_metrics\n        )\n\n    def weighted_sum(self):\n        \"\"\"Returns the weighted sum of all metrics. Can be used as a cost function.\"\"\"\n        used_metrics = [\n            metric\n            for metric in self.metrics.keys()\n            if self.metrics[metric][\"weight\"] is not None\n        ]\n        total_weight = sum(self.metrics[metric][\"weight\"] for metric in used_metrics)\n        return (\n            sum(\n                self.metrics[metric][\"value\"] * self.metrics[metric][\"weight\"]\n                for metric in used_metrics\n            )\n            / total_weight\n        )\n\n    def combine_metrics(self, calculate=True):\n        \"\"\"Combine several metrics based on the given multiple criteria decision analysis technique.\"\"\"\n        # Important to loop over initial weights to avoid checking the weight of all metrics when they are not needed\n        if calculate:\n            self.calculate_metrics()\n        return self.metric_combination_strategies[self.metric_combination_strategy]()\n\n    def pretty_print_metrics(self, calculate=False):\n        \"\"\"Prints all metrics and their values in an easily digestible view.\"\"\"\n        combined = self.combine_metrics(calculate=calculate)\n        print(\"-\" * 50)\n        print(\"{:&lt;30s}Value\\tWeight\".format(\"Metric\"))\n        print(\"-\" * 50)\n        for k, v in self.metrics.items():\n            if v[\"value\"]:\n                val_str = f\"{v['value']:.3f}\"\n                print(f\"{k:&lt;30s}{val_str:&lt;5s}\\t{v['weight']}\")\n            else:\n                print(f\"{k:&lt;30s}{str(v['value']):&lt;5s}\\t{v['weight']}\")\n        print(\"-\" * 50)\n        print(f\"Evaluation using {self.metric_combination_strategy}: {combined:.5f}\")\n        print(\"-\" * 50)\n\n    def metric_table(self, calculate=False):\n        \"\"\"Returns a dictionary of metrics and their values. Designed to work with pandas from_records() method.\"\"\"\n        combined = self.combine_metrics(calculate)\n        metrics = {}\n        for k, v in self.metrics.items():\n            metrics[k] = v[\"value\"]\n        metrics[\"combined\"] = combined\n        return metrics\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.__copy__","title":"<code>__copy__()</code>","text":"<p>Return a shallow copy of the MetricsSuite object.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def __copy__(self):\n    \"\"\"Return a shallow copy of the MetricsSuite object.\"\"\"\n    return MetricsSuite(\n        G=self.G,\n        metric_weights=self.initial_weights,\n        metric_combination_strategy=self.metric_combination_strategy,\n        sym_threshold=self.sym_threshold,\n        sym_tolerance=self.sym_tolerance,\n    )\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Return a deep copy of the MetricsSuite object.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Return a deep copy of the MetricsSuite object.\"\"\"\n    return MetricsSuite(\n        G=self.G.copy(),\n        metric_weights=self.initial_weights,\n        metric_combination_strategy=self.metric_combination_strategy,\n        sym_threshold=self.sym_threshold,\n        sym_tolerance=self.sym_tolerance,\n    )\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a detailed string representation of the MetricsSuite object.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a detailed string representation of the MetricsSuite object.\"\"\"\n    return (\n        f\"MetricsSuite(graph={self._filename}, metric_weights={self.initial_weights}, \"\n        f\"metric_combination_strategy={self.metric_combination_strategy}, sym_threshold={self.sym_threshold}, \"\n        \"sym_tolerance={self.sym_tolerance})\"\n    )\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.__str__","title":"<code>__str__()</code>","text":"<p>Return a concise string representation of the MetricsSuite object.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a concise string representation of the MetricsSuite object.\"\"\"\n    return (\n        f\"MetricsSuite({self._filename}) object with {len(self.metrics)} metrics.\"\n    )\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.apply_layout","title":"<code>apply_layout(pos)</code>","text":"<p>Applies the given layout to the graph.</p>"},{"location":"metricssuite/#graphreadability.MetricsSuite.apply_layout--parameters","title":"Parameters","text":"<p>pos : dict(node_id, tuple(float, float))     Dictionary of node positions.</p>"},{"location":"metricssuite/#graphreadability.MetricsSuite.apply_layout--returns","title":"Returns","text":"<p>None</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def apply_layout(self, pos):\n    \"\"\"Applies the given layout to the graph.\n\n    Parameters\n    ----------\n    pos : dict(node_id, tuple(float, float))\n        Dictionary of node positions.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # Convert to x and y attributes\n    xy = {k: {\"x\": v[0], \"y\": v[1]} for k, v in pos.items()}\n    nx.set_node_attributes(self.G, xy)\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.calculate_metric","title":"<code>calculate_metric(metric=None)</code>","text":"<p>Calculate the value of the given metric by calling the associated function.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def calculate_metric(self, metric: str = None):\n    \"\"\"Calculate the value of the given metric by calling the associated function.\"\"\"\n    if metric is None:\n        raise ValueError(\n            \"No metric provided. Did you mean to call calculate_metrics()?\"\n        )\n\n    try:\n        self.metrics[metric][\"value\"] = self.metrics[metric][\"func\"](self.G)\n    except Exception as e:\n        print(f\"Error calculating metric {metric}: {e}\")\n        self.metrics[metric][\"value\"] = None\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.calculate_metrics","title":"<code>calculate_metrics(calculate_all=False)</code>","text":"<p>Calculates the values of all metrics with non-zero weights.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def calculate_metrics(self, calculate_all=False):\n    \"\"\"Calculates the values of all metrics with non-zero weights.\"\"\"\n    n_metrics = 0\n    for metric in self.metrics:\n        if self.metrics[metric][\"weight\"] is not None or calculate_all:\n            self.calculate_metric(metric)\n            n_metrics += 1\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.combine_metrics","title":"<code>combine_metrics(calculate=True)</code>","text":"<p>Combine several metrics based on the given multiple criteria decision analysis technique.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def combine_metrics(self, calculate=True):\n    \"\"\"Combine several metrics based on the given multiple criteria decision analysis technique.\"\"\"\n    # Important to loop over initial weights to avoid checking the weight of all metrics when they are not needed\n    if calculate:\n        self.calculate_metrics()\n    return self.metric_combination_strategies[self.metric_combination_strategy]()\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.copy","title":"<code>copy(deep=True, memo=None)</code>","text":"<p>Return a copy of the MetricsSuite object, defaulting to a deep copy.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def copy(self, deep=True, memo=None):\n    \"\"\"Return a copy of the MetricsSuite object, defaulting to a deep copy.\"\"\"\n    if deep is True or memo is not None:\n        return self.__deepcopy__(memo)\n    else:\n        return self.__copy__()\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.load_graph_test","title":"<code>load_graph_test(nxg=nx.sedgewick_maze_graph)</code>","text":"<p>Loads a test graph with a random layout.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def load_graph_test(self, nxg=nx.sedgewick_maze_graph):\n    \"\"\"Loads a test graph with a random layout.\"\"\"\n    G = nxg()\n    pos = nx.random_layout(G)\n    for k, v in pos.items():\n        pos[k] = {\"x\": v[0], \"y\": v[1]}\n\n    nx.set_node_attributes(G, pos)\n    return G\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.metric_table","title":"<code>metric_table(calculate=False)</code>","text":"<p>Returns a dictionary of metrics and their values. Designed to work with pandas from_records() method.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def metric_table(self, calculate=False):\n    \"\"\"Returns a dictionary of metrics and their values. Designed to work with pandas from_records() method.\"\"\"\n    combined = self.combine_metrics(calculate)\n    metrics = {}\n    for k, v in self.metrics.items():\n        metrics[k] = v[\"value\"]\n    metrics[\"combined\"] = combined\n    return metrics\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.pretty_print_metrics","title":"<code>pretty_print_metrics(calculate=False)</code>","text":"<p>Prints all metrics and their values in an easily digestible view.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def pretty_print_metrics(self, calculate=False):\n    \"\"\"Prints all metrics and their values in an easily digestible view.\"\"\"\n    combined = self.combine_metrics(calculate=calculate)\n    print(\"-\" * 50)\n    print(\"{:&lt;30s}Value\\tWeight\".format(\"Metric\"))\n    print(\"-\" * 50)\n    for k, v in self.metrics.items():\n        if v[\"value\"]:\n            val_str = f\"{v['value']:.3f}\"\n            print(f\"{k:&lt;30s}{val_str:&lt;5s}\\t{v['weight']}\")\n        else:\n            print(f\"{k:&lt;30s}{str(v['value']):&lt;5s}\\t{v['weight']}\")\n    print(\"-\" * 50)\n    print(f\"Evaluation using {self.metric_combination_strategy}: {combined:.5f}\")\n    print(\"-\" * 50)\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.reset_metrics","title":"<code>reset_metrics()</code>","text":"<p>Resets all metric values and is_calculated flags to None and False, respectively.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def reset_metrics(self):\n    \"\"\"Resets all metric values and is_calculated flags to None and False, respectively.\"\"\"\n    for metric in self.metrics:\n        self.metrics[metric][\"value\"] = None\n        self.metrics[metric][\"is_calculated\"] = False\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.set_weights","title":"<code>set_weights(metric_weights)</code>","text":"<p>Set the weights of the metrics in the MetricsSuite object.</p>"},{"location":"metricssuite/#graphreadability.MetricsSuite.set_weights--parameters","title":"Parameters","text":"<p>metric_weights : dict     Dictionary of metric:weight key/values.</p>"},{"location":"metricssuite/#graphreadability.MetricsSuite.set_weights--returns","title":"Returns","text":"<p>dict     Dictionary of metric:weight key/values for metrics with non-zero weights.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def set_weights(self, metric_weights: Sequence[float]):\n    \"\"\"Set the weights of the metrics in the MetricsSuite object.\n\n    Parameters\n    ----------\n    metric_weights : dict\n        Dictionary of metric:weight key/values.\n\n    Returns\n    -------\n    dict\n        Dictionary of metric:weight key/values for metrics with non-zero weights.\n    \"\"\"\n    metric_weights = {\n        metric: weight for metric, weight in metric_weights.items() if weight &gt; 0\n    }\n\n    if any(metric_weights[metric] &lt; 0 for metric in metric_weights):\n        raise ValueError(\"Metric weights must be positive.\")\n\n    for metric in self.metrics:\n        self.metrics[metric][\"weight\"] = (\n            metric_weights[metric] if metric in metric_weights else None\n        )\n\n    return {\n        metric: weight for metric, weight in metric_weights.items() if weight &gt; 0\n    }\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.weighted_prod","title":"<code>weighted_prod()</code>","text":"<p>Returns the weighted product of all metrics. Should NOT be used as a cost function - may be useful for comparing graphs.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def weighted_prod(self):\n    \"\"\"Returns the weighted product of all metrics. Should NOT be used as a cost function - may be useful for comparing graphs.\"\"\"\n    used_metrics = [\n        metric\n        for metric in self.metrics.keys()\n        if self.metrics[metric][\"weight\"] is not None\n    ]\n    for metric in used_metrics:\n        if self.metrics[metric][\"value\"] is None:\n            self.calculate_metric(metric)\n    return math.prod(\n        self.metrics[metric][\"value\"] * self.metrics[metric][\"weight\"]\n        for metric in used_metrics\n    )\n</code></pre>"},{"location":"metricssuite/#graphreadability.MetricsSuite.weighted_sum","title":"<code>weighted_sum()</code>","text":"<p>Returns the weighted sum of all metrics. Can be used as a cost function.</p> Source code in <code>graphreadability/core/metricssuite.py</code> <pre><code>def weighted_sum(self):\n    \"\"\"Returns the weighted sum of all metrics. Can be used as a cost function.\"\"\"\n    used_metrics = [\n        metric\n        for metric in self.metrics.keys()\n        if self.metrics[metric][\"weight\"] is not None\n    ]\n    total_weight = sum(self.metrics[metric][\"weight\"] for metric in used_metrics)\n    return (\n        sum(\n            self.metrics[metric][\"value\"] * self.metrics[metric][\"weight\"]\n            for metric in used_metrics\n        )\n        / total_weight\n    )\n</code></pre>"},{"location":"references/","title":"References","text":"<p>Two papers served as primary references to this work:</p> <ol> <li>G. J. Mooney, H. C. Purchase, M. Wybrow, and S. G. Kobourov, \u201cThe Multi-Dimensional Landscape of Graph Drawing Metrics\u201d.</li> <li>C. Dunne, S. I. Ross, B. Shneiderman, and M. Martino, \u201cReadability metric feedback for aiding node-link visualization designers,\u201d IBM Journal of Research and Development, vol. 59, no. 2/3, p. 14:1-14:16, Mar. 2015, doi: 10.1147/JRD.2015.2411412</li> </ol> <p>Additional thanks to Gavin Mooney, who shared the code accompanying [1] on GitHub and permitted my reuse.</p>"}]}